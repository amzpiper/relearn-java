## Design-Pattern
>设计模式(Design pattern)代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。
>
>https://www.cnblogs.com/yueguanguanyun/p/9584501.html
>https://www.runoob.com/design-pattern/proxy-pattern.html

## 1、单例模式(Singleton Pattern)
``` 
实现方式：
    a) 将被实现的类的构造方法设计成private的。
    b) 添加此类引用的静态成员变量，并为其实例化。
    c)  在被实现的类中提供公共的CreateInstance函数，返回实例化的此类,就是b中的静态成员变量。
优点： 
    1.在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例 
    2.单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 
    3.提供了对唯一实例的受控访问。 
    4.由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。 
    5.允许可变数目的实例。 
    6.避免对共享资源的多重占用。 
缺点： 
    1.不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。 
    2.由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。 
    3.单例类的职责过重，在一定程度上违背了“单一职责原则”。 
    4.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。 
使用注意事项： 
    1.使用时不能用反射模式创建单例，否则会实例化一个新的对象 
    2.使用懒单例模式时注意线程安全问题 
    3.单例模式和懒单例模式构造方法都是私有的，因而是不能被继承的，有些单例模式可以被继承(如登记式模式) 
适用场景：
    单例模式只允许创建一个对象，因此节省内存，加快对象访问速度，因此对象需要被公用的场合适合使用，如多个模块使用同一个数据源连接对象等等。如： 
    1.需要频繁实例化然后销毁的对象。 
    2.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 
    3.有状态的工具类对象。 
    4.频繁访问数据库或文件的对象。 
以下都是单例模式的经典使用场景： 
    1.资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。 
    2.控制资源的情况下，方便资源之间的互相通信。如线程池等。 
应用场景举例： 
    1.外部资源：每台计算机有若干个打印机，但只能有一个PrinterSpooler，以避免两个打印作业同时输出到打印机。
      内部资源：大多数软件都有一个(或多个)属性文件存放系统配置，这样的系统应该有一个对象管理这些属性文件
    2. Windows的TaskManager(任务管理器)就是很典型的单例模式(这个很熟悉吧)，想想看，是不是呢，你能打开两个windows task manager吗？ 不信你自己试试看哦~ 
    3. windows的Recycle Bin(回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 
    4. 网站的计数器，一般也是采用单例模式实现，否则难以同步。 
    5. 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。 
    6. Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。 
    7. 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。 
    8. 多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。 
    9. 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。 
    10. HttpApplication 也是单位例的典型应用。熟悉ASP.Net(IIS)的整个请求生命周期的人应该知道HttpApplication也是单例模式，所有的HttpModule都共享一个HttpApplication实例. 
```

## 2、策略模式(Strategy Pattern)
```
实现方式：
a)提供公共接口抽象类，定义需要使用策略的方法。(策略抽象类)
b)多个实现策略抽象类的实现类。(策略实现类)
c)环境类，对多个实现类的封装，提供接口类型的成员量，可以在客户端中切换。
d)客户端调用环境类进行不同策略的切换。
注：Jdk中的TreeSet和TreeMap的排序功能就是使用了策略模式。

意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。
何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。
如何解决：将这些算法封装成一个一个的类，任意地替换。
关键代码：实现同一个接口。
应用实例： 
1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 
2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 
3、JAVA AWT 中的 LayoutManager。
优点： 
1、算法可以自由切换。 
2、避免使用多重条件判断(if-else)语句。
3、扩展性良好。
缺点： 
1、策略类会增多。 
2、所有策略类都需要对外暴露。
使用场景： 
1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地
让一个对象在许多行为中选择一种行为。 
2、一个系统需要动态地在几种算法中选择一种。 
3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。
注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。
```

## 3、代理模式(Proxy Pattern)
>在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。
在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。
```
意图：为其他对象提供一种代理以控制对这个对象的访问。
主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，
有些对象由于某些原因(比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问)，
直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
何时使用：想在访问一个类时做一些控制。
如何解决：增加中间层。
关键代码：实现与被代理类组合
应用实例： 
1、Windows 里面的快捷方式。
2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。
3、买火车票不一定在火车站买，也可以去代售点。 
4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 
5、spring aop。
优点： 1、职责清晰。 2、高扩展性。 3、智能化。
缺点： 
1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 
2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。
使用场景：
按职责来划分，通常有以下使用场景： 
1、远程代理。 
2、虚拟代理。 
3、Copy-on-Write 代理。 
4、保护(Protect or Access)代理。 
5、Cache代理。 
6、防火墙(Firewall)代理。 
7、同步化(Synchronization)代理。 
8、智能引用(Smart Reference)代理。
注意事项： 
1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 
2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。
```
### 一) 静态代理(Static Proxy Pattern)
```
实现方式：
a)为真实类和代理类提供的公共接口或抽象类。(租房)
b)真实类，具体实现逻辑，实现或继承a。(房主向外租房)
c)代理类，实现或继承a，有对b的引用，调用真实类的具体实现。(中介)
d)客户端，调用代理类实现对真实类的调用。(租客租房)
代理模式主要使用了 Java 的多态，干活的是被代理类，代理类主要是接活。
静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐
```
### 二) 动态代理(Dynamic Proxy Pattern)
```
实现方式：
a)公共的接口(必须是接口，因为Proxy类的newProxyInstance方法的第二参数必须是个接口类型的Class)
b)多个真实类，具体实现的业务逻辑。
c)代理类，实现InvocationHandler接口，提供Object成员变量，和Set方法，便于客户端切换。
d)客户端，获得代理类的实例，为object实例赋值，调用Proxy.newproxyinstance方法在程序运行时生成继承公共接口的实例，调用相应方法，此时方法的执行由代理类实现的Invoke方法接管。

利用反射机制在运行时创建代理类。
接口、被代理类不变，我们构建一个handler类来实现InvocationHandler接口。
JDK动态代理使用的局限性：
通过反射类Proxy和InvocationHandler回调接口实现的jdk动态代理，
要求委托类必须实现一个接口，但事实上并不是所有类都有接口，对于没有实现接口的类，便无法使用该方方式实现动态代理。
https://www.jianshu.com/p/9bcac608c714
```

## 4、观察者模式(Observer Pattern)
>当对象间存在一对多关系时，则使用观察者模式(Observer Pattern)。
>比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。
```
实现方式：
a)角色抽象类(提供对观察者的添加，删除和通知功能)。
b)角色具体类，实现a，维护一个c的集合(对角色抽象类的实现)。
c)观察者抽象类(被角色通知后实现的方法)。
d)观察者实现类，实现c(多个)。
注：JDK提供了对观察者模式的支持，使用Observable类和Observer接口

意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。
何时使用：一个对象(目标对象)的状态发生改变，所有的依赖对象(观察者对象)都将得到通知，进行广播通知。
如何解决：使用面向对象技术，可以将这种依赖关系弱化。
关键代码：在抽象类里有一个 ArrayList 存放观察者们。
应用实例： 
1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 
2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。
优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。
缺点： 
1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 
2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 
3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。
使用场景：
一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。
一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。
一个对象必须通知其他对象，而并不知道这些对象是谁。
需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。
注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。
```

## 5、装饰模式(Decorator Pattern)
``` 
实现方式：
a)抽象的被装饰角色 (所有的角色都要直接或间接的实现本角色)
b)具体的被装饰角色，实现或继承a (被功能扩展的角色)
c)装饰角色，实现或继承a (本类有对a的引用，所有的具体装饰角色都需要继承这个角色)
d)多个具体修饰角色 ，继承c(对被装饰角色的功能扩展，可以任意搭配使用)

意图：动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。该模式以对客 户端透明的方式扩展对象的功能。
主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。
何时使用：在不想增加很多子类的情况下扩展类。
适用环境:
(1)在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
(2)处理那些可以撤消的职责。
(3)当不能采用生成子类的方法进行扩充时。
一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。
另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。
关键代码：
1、Component类充当抽象角色，不应该具体实现。
2、修饰类引用和继承 Component类，具体扩展类重写父类方法。
优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。
缺点：多层装饰比较复杂。
应用实例： 
1、孙悟空有 72 变，当他变成"庙宇"后，他的根本还是一只猴子，但是他又有了庙宇的功能。 
2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。
在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。
使用场景： 
1、扩展一个类的功能。 
2、动态增加功能，动态撤销。
注意事项：可代替继承。
```

## 6、适配器模式(Observer Pattern)
```
作为两个不兼容的接口之间的桥梁,结合了两个独立接口的功能。
意图：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。
主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。
何时使用： 
1、系统需要使用现有的类，而此类的接口不符合系统的需要。 
2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。
3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象
，实现飞的接口。）
使用场景：有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。
如何解决：继承或依赖（推荐）。
关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。
应用实例： 
1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。
2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，
则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。
3、在 LINUX 上运行 WINDOWS 程序。
4、JAVA 中的 jdbc。
优点:
1.更好的复用性
系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。
2.更好的扩展性
在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。
缺点:
过多的使用适配器，会让系统非常零乱，不易整体进行把握。
比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，
一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。
注意事项：适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。
```
### 6.1、类适配器（子类继承方式）
```
实现方式：
a)目标抽象角色（定义客户要用的接口）
b)适配器（实现a继承c，作为一个转换器被客户调用）
c)待适配器（真正需要被调用的）
d)客户端（借用a的实例调用c的方法）
```

### 6.2、对象适配器（对象的组合方式）- todo
```
实现方式：
a)目标抽象角色（定义客户要用的接口）
b)适配器（实现a，维护一个c的引用，作为一个转换器被d调用）
c)待适配器（真正需要被调用的）
d)客户端（此类，借用a类的实例调用c类的方法，类似静态代理，但是解决的问题不同）
```
### 6.3、缺省的方式 - todo
```
实现方式：
a)抽象接口
b)实现a的适配器类（空实现）
c)客户端，继承b，调用b中的方法，不必直接实现a（直接实现a需要实现a中的所有的方法）
```

## 7、命令模式(Observer Pattern)
```

```

## 8、组合模式(Observer Pattern)
```

```

## 9、简单工厂模式(Observer Pattern)
```

```

## 10、模板模式(Observer Pattern)
```

```

